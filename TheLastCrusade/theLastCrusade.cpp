#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <list>
#include <stack>
#include <set>
#include <queue>
#include <algorithm>

using namespace std;

const int INVALID_ID = -1;
const int INVALID_NODE_DEPTH = -1;
const int TREE_ROOT_NODE_DEPTH = 1;
const int ZERO_CHAR = '0';
const int INVALID_COORD = -1;
const int DIRECTION_COUNT = 4;

enum RoomType {
	RT_INVALID = -1,
	RT_0 = 0,
	RT_1,
	RT_2,
	RT_3,
	RT_4,
	RT_5,
	RT_6,
	RT_7,
	RT_8,
	RT_9,
	RT_10,
	RT_11,
	RT_12,
	RT_13,
};

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class Coords {
public:
	Coords();
	Coords(int xCoord, int yCoord);

	int getXCoord() const {
		return xCoord;
	}

	int getYCoord() const {
		return yCoord;
	}

	void setXCoord(int xCoord) { this->xCoord = xCoord; }
	void setYCoord(int yCoord) { this->yCoord = yCoord; }

	Coords& operator=(const Coords& other);
	bool operator==(const Coords& other);
	Coords operator+(const Coords& other);
	Coords& operator+=(const Coords& other);

	bool isValid() const;
	void debug() const;
private:
	int xCoord;
	int yCoord;
};

//*************************************************************************************************************
//*************************************************************************************************************

Coords::Coords() :
	xCoord(INVALID_COORD),
	yCoord(INVALID_COORD)
{
}

//*************************************************************************************************************
//*************************************************************************************************************

Coords::Coords(
	int xCoord,
	int yCoord
) :
	xCoord(xCoord),
	yCoord(yCoord)
{
}

//*************************************************************************************************************
//*************************************************************************************************************

Coords& Coords::operator=(const Coords& other) {
	if (this != &other) {
		xCoord = other.xCoord;
		yCoord = other.yCoord;
	}

	return *this;
}

//*************************************************************************************************************
//*************************************************************************************************************

bool Coords::operator==(const Coords& other) {
	return (xCoord == other.xCoord) && (yCoord == other.yCoord);
}

//*************************************************************************************************************
//*************************************************************************************************************

Coords Coords::operator+(const Coords& other) {
	return Coords(xCoord + other.xCoord, yCoord + other.yCoord);
}

//*************************************************************************************************************
//*************************************************************************************************************

Coords& Coords::operator+=(const Coords& other) {
	xCoord += other.xCoord;
	yCoord += other.yCoord;

	return *this;
}

//*************************************************************************************************************
//*************************************************************************************************************

bool Coords::isValid() const {
	return INVALID_COORD != xCoord && INVALID_COORD != yCoord;
}

//*************************************************************************************************************
//*************************************************************************************************************

void Coords::debug() const {
	cerr << "Position: X=" << xCoord << ", Y=" << yCoord << endl;
}

//*************************************************************************************************************
//*************************************************************************************************************

enum Direction {
	DIR_INVALID = -1,
	DIR_N = 0,
	DIR_E,
	DIR_S,
	DIR_W,
};

//*************************************************************************************************************
//*************************************************************************************************************

Coords DIRECTIONS[DIRECTION_COUNT] = {
	Coords(0, -1), // N
	Coords(1,  0), // E
	Coords(0,  1), // S
	Coords(-1,  0), // W
};

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class Room {
public:
	Room();
	~Room();

	RoomType getType() const {
		return type;
	}

	void setType(RoomType type) { this->type = type; }

private:
	RoomType type;
};

//*************************************************************************************************************
//*************************************************************************************************************

Room::Room() : type(RT_INVALID) {

}

//*************************************************************************************************************
//*************************************************************************************************************

Room::~Room() {

}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class Dungeon {
public:
	Dungeon();
	~Dungeon();

	void init(int height, int width);
	void setRoomType(Coords coords, RoomType roomType);
	RoomType getRoomType(Coords coords) const;

	void debug() const;
private:
	int width;
	int height;

	Room** map;
};

//*************************************************************************************************************
//*************************************************************************************************************

Dungeon::Dungeon() {

}

//*************************************************************************************************************
//*************************************************************************************************************

Dungeon::~Dungeon() {
	if (map) {
		for (int rowIdx = 0; rowIdx < height; ++rowIdx) {
			if (map[rowIdx]) {
				delete[] map[rowIdx];
				map[rowIdx] = NULL;
			}
		}

		delete[] map;
		map = NULL;
	}
}

//*************************************************************************************************************
//*************************************************************************************************************

void Dungeon::init(int height, int width) {
	this->height = height;
	this->width = width;

	map = new Room*[height];

	for (int rowIdx = 0; rowIdx < height; ++rowIdx) {
		map[rowIdx] = new Room[width];
	}
}

//*************************************************************************************************************
//*************************************************************************************************************

void Dungeon::setRoomType(Coords coords, RoomType roomType) {
	map[coords.getYCoord()][coords.getXCoord()].setType(roomType);
}

//*************************************************************************************************************
//*************************************************************************************************************

RoomType Dungeon::getRoomType(Coords coords) const {
	return map[coords.getYCoord()][coords.getXCoord()].getType();
}

//*************************************************************************************************************
//*************************************************************************************************************

void Dungeon::debug() const {
	for (int rowIdx = 0; rowIdx < height; ++rowIdx) {
		for (int colIdx = 0; colIdx < width; ++colIdx) {
			cerr << map[rowIdx][colIdx].getType();
		}

		cerr << endl;
	}
}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class Indy {
public:
	Indy();
	~Indy();

	Coords getPosition() const {
		return position;
	}

	void setPosition(Coords coords) { this->position = position; }

private:
	Coords position;
};

//*************************************************************************************************************
//*************************************************************************************************************

Indy::Indy() :
	position()
{

}

//*************************************************************************************************************
//*************************************************************************************************************

Indy::~Indy() {

}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

class Game {
public:
	Game();
	~Game();

	void initGame();
	void gameLoop();
	void getGameInput();
	void getTurnInput();
	void turnBegin();
	void makeTurn();
	void turnEnd();
	void play();

	void debug() const;

	bool indyCanMovefromTo(Coords from, Coords to, Direction movingDir) const;

private:
	int turnsCount;

	Dungeon* dungeon;
	Indy* indy;
};

//*************************************************************************************************************
//*************************************************************************************************************

Game::Game() :
	turnsCount(0),
	dungeon(NULL),
	indy(NULL)
{
}

//*************************************************************************************************************
//*************************************************************************************************************

Game::~Game() {
	if (dungeon) {
		delete dungeon;
		dungeon = NULL;
	}

	if (indy) {
		delete indy;
		indy = NULL;
	}
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::initGame() {
	indy = new Indy();
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::gameLoop() {
	while (true) {
		getTurnInput();
		turnBegin();
		makeTurn();
		turnEnd();
	}
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::getGameInput() {
	int W; // number of columns.
	int H; // number of rows.
	cin >> W >> H; cin.ignore();

	dungeon = new Dungeon();
	dungeon->init(H, W);

	for (int rowIdx = 0; rowIdx < H; ++rowIdx) {
		for (int colIdx = 0; colIdx < W; ++colIdx) {
			int roomTypeInt;
			cin >> roomTypeInt;

			RoomType roomType = (RoomType)roomTypeInt;
			dungeon->setRoomType(Coords(colIdx, rowIdx), roomType);
		}

		cin.ignore();
	}

	int EX; // the coordinate along the X axis of the exit (not useful for this first mission, but must be read).
	cin >> EX; cin.ignore();
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::getTurnInput() {
	int XI;
	int YI;
	string POS;
	cin >> XI >> YI >> POS; cin.ignore();

	indy->setPosition(Coords(XI, YI));
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::turnBegin() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::makeTurn() {
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::turnEnd() {
	++turnsCount;
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::play() {
	initGame();
	getGameInput();
	gameLoop();
}

//*************************************************************************************************************
//*************************************************************************************************************

void Game::debug() const {
	dungeon->debug();
}

bool Game::indyCanMovefromTo(Coords from, Coords to, Direction movingDir) const {
	bool canMove = false;

	RoomType fromType = dungeon->getRoomType(from);
	RoomType toType = dungeon->getRoomType(to);

	return canMove;
}

//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------

#ifdef TESTS
#include "debug.h"
#endif // TESTS

int main(int argc, char** argv) {
#ifdef TESTS
	doctest::Context context;
	int res = context.run();
#else
	Game game;
	game.play();
#endif // TESTS

	return 0;
}